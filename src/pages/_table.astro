---
import { type TransactionDto, toDateString } from "lib/client";
import { css } from "css";

interface Props {
	transactions: TransactionDto[];
	startAfter: Date;
	hasNext: boolean;
}

const { transactions, startAfter, hasNext } = Astro.props;
---

<fetch-more hasNext={hasNext} startAfter={startAfter}>
	<template class="new">
		<a
			class={css({
				paddingX: 2,
				animation: "tempBgColorChange 0.8s ease-in-out",
			})}
		>
			<span
				class={css({
					textAlign: "start",
				})}></span>
			<span></span>
			<span
				class={css({
					textAlign: "end",
				})}></span>
		</a>
	</template>
	<template class="old">
		<a
			class={css({
				paddingX: 2,
			})}
		>
			<span
				class={css({
					textAlign: "start",
				})}></span>
			<span></span>
			<span
				class={css({
					textAlign: "end",
				})}></span>
		</a>
	</template>
	<div
		class={css({
			fontSize: "md",
			textAlign: "center",
			borderCollapse: "collapse",
			borderSpacing: 0,
			width: "100vw",
			height: "90vh",
			overflowY: "auto",
			paddingBottom: "5rem",
		})}
	>
		<div
			class={"table " +
				css({
					"& > *": {
						display: "grid",
						gridTemplateColumns: "1fr 4fr 2fr",
						paddingY: "1rem",
						width: "100vw",
						justifyContent: "space-between",
						_odd: {
							backgroundColor: "gray.100",
						},
					},
				})}
		>
			{
				transactions.map((d, index) => (
						<a
						href={`/transactions/${d.id}`}
						class={`${index === (transactions.length - 10) ? "loader " : ""}` + css({
							paddingX: 2,
						})}
					>
						<span
							class={css({
								textAlign: "start",
							})}
							data-date={d.date}
						>
							{toDateString(d.date)}
						</span>
						<span>{d.description}</span>
						<span
							class={css({
								textAlign: "end",
							})}
						>
							{d.amount.toLocaleString()}
						</span>
					</a>
				))
			}
		</div>
	</div>
</fetch-more>

<script>
	import { createTransactionElement, type TransactionDto } from "lib/client";
  import { nanoid } from "nanoid";

	async function fetchTransactions({ startAfter }: { startAfter: string }) {
		return (await fetch(
			`/api/paged-transactions/${startAfter}.json`, {
			headers: {
				"Content-Type": "application/json",
				"X-B3-TraceId": nanoid(),
				"X-B3-ParentSpanId": "/pages/index/fetch-more",
			},
		}).then(
			(response) => response.json(),
		)) as { data: TransactionDto[]; startAfter: string; hasNext: boolean };
	}

	class FetchMore extends HTMLElement {
		constructor() {
			super();

			let state = {
				startAfter: this.getAttribute("startAfter")!,
				hasNext: Boolean(this.getAttribute("hasNext")),
				initial: true,
			};

			const table = this.querySelector(".table");

			if (table === null) {
				throw new Error("table not found");
			}

			const template = this.querySelector<HTMLTemplateElement>("template.old")!;

			if (template === null) {
				throw new Error("template not found");
			}

			const observer = new IntersectionObserver(async (entries) => {
				if (entries[0]!.isIntersecting) {
					if (!state.hasNext) {
						observer.disconnect();
						return;
					}

					const { data, startAfter, hasNext } = await fetchTransactions({
						startAfter: state.startAfter,
					});

					for (const d of data) {
						const a = createTransactionElement(template, d);

						table!.append(a);
					}

					state = { startAfter, hasNext, initial: false };
				}
			});

			const loader = this.querySelector(".loader");

			observer.observe(loader!);
		}
	}

	customElements.define("fetch-more", FetchMore);
</script>
