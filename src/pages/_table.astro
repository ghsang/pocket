---
import { css } from "css";
import { type TransactionDto, convertDate } from "lib/client";

interface Props {
	transactions: TransactionDto[];
	hasNext: boolean;
}

const { transactions, hasNext } = Astro.props;
---

<fetch-more data-hasnext={hasNext}>
	<div class={css({ height: "90vh" })}>
		<div
			class={css({
				display: "block",
				fontSize: "md",
				textAlign: "center",
				borderCollapse: "collapse",
				borderSpacing: 0,
				width: "100vw",
				height: "100%",
				overflowY: "auto",
			})}
		>
			<div
				class={"table " +
					css({
						"& > *": {
							display: "grid",
							gridTemplateColumns: "1fr 4fr 2fr",
							paddingY: "1rem",
							width: "100vw",
							justifyContent: "space-between",
							_odd: {
								backgroundColor: "gray.100",
							},
						},
					})}
			>
				{
					transactions.map((d) => (
						<a 
							href={`/transactions/${d.id}`} 
							class={css({paddingX: 2})}
						>
							<span>{convertDate(d.date)}</span>
							<span>{d.description}</span>
							<span>{d.amount.toLocaleString()}</span>
						</a>
					))
				}
			</div>
			<div class="loader"></div>
		</div>
	</div>
</fetch-more>

<script>
	import { type TransactionDto, convertDate } from "lib/client";

	class FetchMore extends HTMLElement {
		constructor() {
			super();

			async function fetchTransactions({ startAfter }: { startAfter: string }) {
				return (await fetch(`/api/paged-transactions/${startAfter}.json`).then(
					(response) => response.json(),
				)) as { data: TransactionDto[]; startAfter: string; hasNext: boolean };
			}

			let state = {
				startAfter: new Date().toISOString(),
				hasNext: Boolean(this.dataset.hasNext),
				initial: true,
			};

			const table = this.querySelector(".table");

			function createTransactionElement(d: TransactionDto) {
				const a = document.createElement("a");

				a.setAttribute("href", `/transactions/${d.id}`);

				a.innerHTML = `
					<span>${convertDate(d.date)}</span>
					<span>${d.description}</span>
					<span>${d.amount.toLocaleString()}</span>
				`;

				return a;
			}

			const observer = new IntersectionObserver(async (entries) => {
				if (entries[0]!.isIntersecting) {
					if (!state.hasNext) {
						observer.disconnect();
						return;
					}

					if (state.initial) {
						state.initial = false;
						return;
					}

					const { data, startAfter, hasNext } = await fetchTransactions({
						startAfter: state.startAfter,
					});

					for (const d of data) {
						const el = createTransactionElement(d);

						table!.appendChild(el);
					}

					state = { startAfter, hasNext, initial: false };
				}
			});

			const loader = this.querySelector(".loader");

			observer.observe(loader!);
		}
	}

	customElements.define("fetch-more", FetchMore);
</script>
